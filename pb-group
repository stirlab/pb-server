#!/usr/bin/env node

var path = require('path');
var util = require('util');
var format = util.format;

var args = process.argv.slice(1);
var program = path.basename(args.shift());

var async = require('async');
var hostile = require('hostile')
var PbServer = require('./pb-server');

var log = function() {
  console.log.apply(this, arguments);
}

var config = require('./config');

var pb = new PbServer(config.pb, config.ssh);
// Uncomment this to use the mock handlers, with success responses.
// Actions not included in the array will mock a failure state.
//pb.useMockHandlers(['start', 'stop', 'update', 'service']);

var debugCallback = function(err, data) {
  if (err) {
    log("ERROR: " + String(err));
  }
  else {
    log(data);
  }
}

function bytesToSize(bytes) {
   var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
   if (bytes == 0) return '0 Byte';
   var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
   return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
};

var executeFuncs = function(groupLabel, serverFunc, cb) {
  var funcs = [];
  if (config.pb.groups[groupLabel] && config.pb.groups[groupLabel].servers) {
    config.pb.groups[groupLabel].servers.forEach(function(serverLabel) {
      var func = serverFunc(serverLabel);
      funcs.push(func);
    });
    async.parallel(funcs, function(err, results) {
      if (err) {
        if (cb) {
          cb(err);
        }
        else {
          log(format("ERROR: %s", err));
        }
      }
      else {
        if (cb) {
          cb(null, results);
        }
        else {
          results.forEach(function(result) {
            log(result);
          });
        }
      }
    });
  }
  else {
    log(format("ERROR: group %s does not exist", groupLabel));
  }
}

var getStatus = function(groupLabel, cb) {
  var getServerFunc = function(serverLabel) {
    return function(next) {
      var getCb = function(err, data) {
        if (err) {
          log(format("ERROR: %s, %s", err, data));
          return next(format("Failed to get server %s", serverLabel));
        }
        else {
          var name = data.properties.name;
          var machineState = data.metadata.state;
          var serverState = data.properties.vmState;
          var cores = data.properties.cores;
          var ram = bytesToSize(data.properties.ram * 1000000);
          var nicId = data.entities.nics.items[0].id;
          var nicCb = function(err, data) {
            if (err) {
              log(format("ERROR: %s, %s", err, data));
              return next(format("Failed to get server %s NIC info", serverLabel));
            }
            else {
              var status = {
                serverLabel: serverLabel,
                name: name,
                machineState: machineState,
                serverState: serverState,
                cores: cores,
                ram: ram,
                ips: data.properties.ips,
              }
              return next(null, status);
            }
          }
          pb.getNic(serverLabel, nicId, nicCb);
        }
      }
      pb.getServer(serverLabel, getCb);
    }
  }
  executeFuncs(groupLabel, getServerFunc, cb);
}

var managedHosts = function(groupLabel) {
  if (config.pb.groups[groupLabel] && config.pb.groups[groupLabel].servers) {
    if (config.pb.groups[groupLabel].manageHostsFile) {
      return config.pb.groups[groupLabel].manageHostsFile;
    }
    else if (config.pb.groups.manageHostsFile) {
      return config.pb.groups.manageHostsFile;
    }
    else {
      return false;
    }
  }
  else {
    log(format("ERROR: group %s does not exist", groupLabel));
    return false;
  }
}

var addHosts = function(groupLabel) {
  if (managedHosts(groupLabel)) {
    var statusCb = function(err, results) {
      if (err) {
        log(format("ERROR: %s", err));
      }
      else {
        results.forEach(function(data) {
          var ip = data.ips[0];
          hostile.set(ip, data.serverLabel, function (err) {
            if (err) {
              log(format("ERROR: cannot set hosts entry for server %s, IP %s: %s", data.serverLabel, ip, err));
            }
            else {
              log(format("Set hosts entry for server %s, IP %s", data.serverLabel, ip));
            }
          });
        });
      }
    }
    getStatus(groupLabel, statusCb);
  }
}

var removeHosts = function(groupLabel) {
  if (managedHosts(groupLabel)) {
    var statusCb = function(err, results) {
      if (err) {
        log(format("ERROR: %s", err));
      }
      else {
        results.forEach(function(data) {
          var ip = data.ips[0];
          hostile.remove(ip, data.serverLabel, function (err) {
            if (err) {
              log(format("ERROR: cannot remove hosts entry for server %s, IP %s: %s", data.serverLabel, ip, err));
            }
            else {
              log(format("Removed hosts entry for server %s, IP %s", data.serverLabel, ip));
            }
          });
        });
      }
    }
    getStatus(groupLabel, statusCb);
  }
}

switch (args[0]) {
  case 'start':
    var groupLabel = args[1];
    var startServerFunc = function(serverLabel) {
      return function(next) {
        var cb = function(err, data) {
          if (err) {
            log(format("ERROR: %s, %s", err, data));
            return next(format("Failed to start server %s", serverLabel));
          }
          else {
            return next(null, format("Started server %s", serverLabel));
          }
        }
        pb.startServerTracked(serverLabel, cb);
      }
    }
    executeFuncs(groupLabel, startServerFunc);
    addHosts(groupLabel);
    break;
  case 'stop':
    var groupLabel = args[1];
    var stopServerFunc = function(serverLabel) {
      return function(next) {
        var shutdownCb = function(err, data) {
          if (err) {
            log(format("ERROR: %s, %s", err, data));
          }
          // Even if there was a failure in shutdown, we still want to stop, so no
          // need to verify what happened here.
          var stopCb = function(err, data) {
            if (err) {
              log(format("ERROR: %s, %s", err, data));
              return next(format("Failed to stop server %s", serverLabel));
            }
            else {
              return next(null, format("Stopped server %s", serverLabel));
            }
          }
          pb.stopServerTracked(serverLabel, stopCb);
        }
        pb.shutdownServerTracked(serverLabel, shutdownCb);
      }
    }
    executeFuncs(groupLabel, stopServerFunc);
    removeHosts(groupLabel);
    break;
  case 'shutdown':
    var groupLabel = args[1];
    var shutdownServerFunc = function(serverLabel) {
      return function(next) {
        var shutdownCb = function(err, data) {
          if (err) {
            log(format("ERROR: %s, %s", err, data));
            return next(format("Failed to shutdown server %s", serverLabel));
          }
          else {
            return next(null, format("Shutdown server %s", serverLabel));
          }
        }
        pb.shutdownServerTracked(serverLabel, shutdownCb);
      }
    }
    executeFuncs(groupLabel, shutdownServerFunc);
    removeHosts(groupLabel);
    break;
  case 'hard-stop':
    var groupLabel = args[1];
    var stopServerFunc = function(serverLabel) {
      return function(next) {
        var stopCb = function(err, data) {
          if (err) {
            log(format("ERROR: %s, %s", err, data));
            return next(format("Failed to hard stop server %s", serverLabel));
          }
          else {
            return next(null, format("Hard stopped server %s", serverLabel));
          }
        }
        pb.stopServerTracked(serverLabel, stopCb);
      }
    }
    executeFuncs(groupLabel, stopServerFunc);
    removeHosts(groupLabel);
    break;
  case 'status':
    var groupLabel = args[1];
    var statusCb = function(err, results) {
      if (err) {
        log(format("ERROR: %s", err));
      }
      else {
        results.forEach(function(data) {
            var info = format("Name: %s\nMachine state: %s\nServer state: %s\nCores: %d\nRAM: %s\nIPs: %s", data.name, data.machineState, data.serverState, data.cores, data.ram, data.ips);
            log(format("Got info for server %s\n", data.serverLabel) + info);
        });
      }
    }
    getStatus(groupLabel, statusCb);
    break;
  case 'update':
    var groupLabel = args[1];
    var profile = args[2];
    var updateServerFunc = function(serverLabel) {
      return function(next) {
        var updateCb = function(err, data) {
          if (err) {
            log(format("ERROR: %s, %s", err, data));
            return next(format("Failed to update server %s", serverLabel));
          }
          else {
            var name = data.properties.name;
            var cores = data.properties.cores;
            var ram = data.properties.ram;
            var stats = format("Name: %s\nCores: %d\nRAM: %s", name, cores, bytesToSize(ram * 1000000));
            return next(null, format("Updated server %s\n", serverLabel) + stats);
          }
        }
        pb.updateServer(serverLabel, profile, updateCb);
      }
    }
    executeFuncs(groupLabel, updateServerFunc);
    break;
  default:
    log("Usage: " + program + " start <group-label> | stop <group-label> | shutdown <group-label> | hard-stop <group-label> | status <group-label> | update <group-label> <profile>");
}

// vi: ft=javascript
